// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion {
  implicit def int2int(i: utilities.Datatype.Int.int): Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i) => Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
     else {
       val (r, s): (BigInt, BigInt) =
         (
             (k: BigInt) =>
               (l: BigInt) =>
                 if (l == 0) (BigInt(0), k)
                 else
                   (k.abs /% l.abs)
         ).apply(k).apply(BigInt(2));
       ((if (BigInt(0) < k) r else (-r) - s), s == BigInt(1))
     })

  def char_of_integer(k: BigInt): Str.char = {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    Str.Chara(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil)     => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[Str.char] = {
    (l.map(c => {
      val k: Int = c.toInt;
      if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal")
    }))
      .map(a => char_of_integer(a))
  }

  def explode(s: String): List[Str.char] = {
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s: String): List[Str.char] = explode(s)

  // conversion from Scala List[Char] to HOL List[Str.char]
  implicit def charList2charList(l: List[Char]): List[Str.char] =
    explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[Str.char] on first position
  implicit def tupleString2tupleString[T](
      t: (List[Char], T)
  ): (List[Str.char], T) = t match {
    case (e1, e2) => (charList2charList(e1), e2)
  }

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2dataint(i: Int.int): utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i) => utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: Str.char): Char = {
    x match {
      case Str.Chara(x1, x2, x3, x4, x5, x6, x7, x8) => {
        var n = 0;
        n = if (x8) 2 * n + 1 else 2 * n;
        n = if (x7) 2 * n + 1 else 2 * n;
        n = if (x6) 2 * n + 1 else 2 * n;
        n = if (x5) 2 * n + 1 else 2 * n;
        n = if (x4) 2 * n + 1 else 2 * n;
        n = if (x3) 2 * n + 1 else 2 * n;
        n = if (x2) 2 * n + 1 else 2 * n;
        n = if (x1) 2 * n + 1 else 2 * n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[Str.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
object equal {
  implicit def `tp67.equal_absint`: equal[tp67.absint] = new equal[tp67.absint]
    {
    val `HOL.equal` = (a: tp67.absint, b: tp67.absint) =>
      tp67.equal_absinta(a, b)
  }
  implicit def `Str.equal_char`: equal[Str.char] = new equal[Str.char] {
    val `HOL.equal` = (a: Str.char, b: Str.char) => Str.equal_chara(a, b)
  }
  implicit def `Lista.equal_list`[A : equal]: equal[List[A]] = new
    equal[List[A]] {
    val `HOL.equal` = (a: List[A], b: List[A]) => Lista.equal_lista[A](a, b)
  }
}

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object Code_Numeral {

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def one_int: int = int_of_integer(BigInt(1))

def plus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) +
                   Code_Numeral.integer_of_int(l))

def zero_int: int = int_of_integer(BigInt(0))

def equal_int(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

def minus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) -
                   Code_Numeral.integer_of_int(l))

def uminus_int(k: int): int =
  int_of_integer((- (Code_Numeral.integer_of_int(k))))

} /* object Int */

object Product_Type {

def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
  case (p, true) => p
  case (p, false) => ! p
  case (true, p) => p
  case (false, p) => ! p
}

} /* object Product_Type */

object Str {

abstract sealed class char
final case class Chara(a: Boolean, b: Boolean, c: Boolean, d: Boolean,
                        e: Boolean, f: Boolean, g: Boolean, h: Boolean)
  extends char

def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
  case (Chara(x1, x2, x3, x4, x5, x6, x7, x8),
         Chara(y1, y2, y3, y4, y5, y6, y7, y8))
    => Product_Type.equal_bool(x1, y1) &&
         (Product_Type.equal_bool(x2, y2) &&
           (Product_Type.equal_bool(x3, y3) &&
             (Product_Type.equal_bool(x4, y4) &&
               (Product_Type.equal_bool(x5, y5) &&
                 (Product_Type.equal_bool(x6, y6) &&
                   (Product_Type.equal_bool(x7, y7) &&
                     Product_Type.equal_bool(x8, y8)))))))
}

} /* object Str */

object Lista {

def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
  case (Nil, Nil) => true
}

} /* object Lista */

object tp67 {

abstract sealed class absint
final case class Integer(a: Int.int) extends absint
final case class Any() extends absint

def equal_absinta(x0: absint, x1: absint): Boolean = (x0, x1) match {
  case (Integer(x1), Any()) => false
  case (Any(), Integer(x1)) => false
  case (Integer(x1), Integer(y1)) => Int.equal_int(x1, y1)
  case (Any(), Any()) => true
}

abstract sealed class option[A]
final case class None[A]() extends option[A]
final case class Some[A](a: A) extends option[A]

abstract sealed class absbool
final case class Vrai() extends absbool
final case class Faux() extends absbool
final case class Possible() extends absbool

def equal_absbool(x0: absbool, x1: absbool): Boolean = (x0, x1) match {
  case (Faux(), Possible()) => false
  case (Possible(), Faux()) => false
  case (Vrai(), Possible()) => false
  case (Possible(), Vrai()) => false
  case (Vrai(), Faux()) => false
  case (Faux(), Vrai()) => false
  case (Possible(), Possible()) => true
  case (Faux(), Faux()) => true
  case (Vrai(), Vrai()) => true
}

def sumabsint(uu: absint, uv: absint): absint = (uu, uv) match {
  case (Integer(a), Integer(b)) => Integer(Int.plus_int(a, b))
  case (Any(), uv) => Any()
  case (uu, Any()) => Any()
}

def subabsint(uu: absint, uv: absint): absint = (uu, uv) match {
  case (Integer(a), Integer(b)) => Integer(Int.minus_int(a, b))
  case (Any(), uv) => Any()
  case (uu, Any()) => Any()
}

def assoc[A : HOL.equal, B](uu: A, x1: List[(A, B)]): option[B] = (uu, x1) match
  {
  case (uu, Nil) => None[B]()
  case (x1, (x, y) :: xs) =>
    (if (HOL.eq[A](x, x1)) Some[B](y) else assoc[A, B](x1, xs))
}

def absevale(x0: expression, e: List[(List[Str.char], absint)]): absint =
  (x0, e) match {
  case (Constant(s), e) => Integer(s)
  case (Variable(v), e) =>
    (assoc[List[Str.char], absint](v, e) match {
       case None() => Integer(Int.uminus_int(Int.one_int))
       case Some(y) => y
     })
  case (Sum(e1, e2), e) => sumabsint(absevale(e1, e), absevale(e2, e))
  case (Sub(e1, e2), e) => subabsint(absevale(e1, e), absevale(e2, e))
}

def absevalc(x0: condition, t: List[(List[Str.char], absint)]): absbool =
  (x0, t) match {
  case (Eq(e1, e2), t) =>
    (if (equal_absinta(absevale(e1, t), Any()) ||
           equal_absinta(absevale(e2, t), Any()))
      Possible()
      else (if (equal_absinta(absevale(e1, t), absevale(e2, t))) Vrai()
             else Faux()))
}

def equal_option[A : HOL.equal](x0: option[A], x1: option[A]): Boolean =
  (x0, x1) match {
  case (None(), Some(x2)) => false
  case (Some(x2), None()) => false
  case (Some(x2), Some(y2)) => HOL.eq[A](x2, y2)
  case (None(), None()) => true
}

def extractabsint(x0: List[(List[Str.char], absint)], uu: List[Str.char]):
      absint
  =
  (x0, uu) match {
  case (Nil, uu) => Integer(Int.uminus_int(Int.one_int))
  case ((x, e) :: t, s) =>
    (if (Lista.equal_lista[Str.char](x, s)) e else extractabsint(t, s))
}

def Set_to_any(x0: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  x0 match {
  case Nil => Nil
  case (s, e) :: t =>
    (if (equal_absinta(e, Integer(Int.uminus_int(Int.one_int))))
      (s, e) :: Set_to_any(t) else (s, Any()) :: Set_to_any(t))
}

def delete(s: List[Str.char], x1: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  (s, x1) match {
  case (s, Nil) => Nil
  case (s, (x, e) :: t) =>
    (if (Lista.equal_lista[Str.char](s, x)) delete(s, t)
      else (x, e) :: delete(s, t))
}

def fusion(x0: List[(List[Str.char], absint)],
            t: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  (x0, t) match {
  case (Nil, t) => Set_to_any(t)
  case ((s, e) :: t1, t2) =>
    (if (equal_option[absint](assoc[List[Str.char], absint](s, t2),
                               None[absint]()))
      (if (equal_absinta(e, Integer(Int.uminus_int(Int.one_int))))
        (s, Integer(Int.uminus_int(Int.one_int))) :: fusion(t1, t2)
        else (s, Any()) :: fusion(t1, t2))
      else {
             val e1 = extractabsint(t2, s): absint;
             (if (equal_absinta(e, e1)) (s, e) :: fusion(t1, delete(s, t2))
               else (s, Any()) :: fusion(t1, delete(s, t2)))
           })
}

def absevals(x0: statement, t: List[(List[Str.char], absint)]):
      (List[(List[Str.char], absint)], Boolean)
  =
  (x0, t) match {
  case (Read(s), t) => ((s, Any()) :: t, true)
  case (Exec(e), t) =>
    (t, ! (equal_absinta(absevale(e, t), Integer(Int.zero_int)) ||
            equal_absinta(absevale(e, t), Any())))
  case (Aff(s, e), t) => ((s, absevale(e, t)) :: t, true)
  case (Seq(s1, s2), t) => (absevals(s1, t) match {
                              case (t1, true) => absevals(s2, t1)
                              case (_, false) => (Nil, false)
                            })
  case (If(c, s1, s2), t) =>
    (if (equal_absbool(absevalc(c, t), Vrai())) absevals(s1, t)
      else (if (equal_absbool(absevalc(c, t), Possible()))
             {
               val (t1, b1) =
                 absevals(s1, t): ((List[(List[Str.char], absint)], Boolean))
               val (t2, b2) =
                 absevals(s2, t): ((List[(List[Str.char], absint)], Boolean));
               (fusion(t1, t2), b1 && b2)
             }
             else absevals(s2, t)))
  case (Print(v), t) => (t, true)
  case (Skip, t) => (t, true)
}

def san3(s: statement): Boolean =
  {
    val (_, b) = absevals(s, Nil): ((List[(List[Str.char], absint)], Boolean));
    b
  }

} /* object tp67 */

object Analyzer {
  def safe(p: statement): Boolean = {
    tp67.san3(p)
  }
}
